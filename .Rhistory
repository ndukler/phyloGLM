library(phyloGLM)
## Setup dataset for testing
## Create tree
tree=ape::read.tree(text = "((A,B),C);")
tree=ape::unroot.phylo(tree)
tree=ape::reorder.phylo(tree,"postorder")
tree$edge.length=c(0.25,0.5,2)
## Settings
nAlleles=2
species=c("A","B","C")
siteInfo=data.frame(A=0.25,B=2)
rateFormula=formula(~A+B)
states=matrix(c(0,1,1),nrow=1)
colnames(states)=tree$tip.label
## Compute site probabilities using epiAllele and construct alleleData object
aData=disCharToProb(states,c(0,1))
ad=alleleData(data=aData,tree=tree,siteInfo = siteInfo)
## Construct two edge group edgeTable
et=getEdgeTable(ad)
et[,edgeGroup:=c(0,1,2)]
##### Begin Tests ######
## -------------------------------------------------------------------------- ##
## construct rateModel
testthat::context("rateModel object can be constructed")
testthat::expect_s4_class(rateMod<-rateModel(data = ad,rateFormula = rateFormula,lineageTable = et),class = "rateModel")
testthat::context("rateModel object getter/setter functions")
## Check that parameter vector is the correct length
testthat::test_that("Parameter vector is retieved correctly",
testthat::expect_equal(getParams(obj = rateMod),rep(1,12)))
testthat::test_that("Parameter vector is set correctly",
testthat::expect_equal({
setParams(rateMod,c(0.1,0.2,0.3),6:8)
getParams(rateMod)[7:9]
},c(0.1,0.2,0.3)))
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
## Check that the stationary distribution, pi is computed correctly
Z=c(1,exp(-sum(rateMod@piDM[1,])))
piProb=Z/sum(Z)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(as.numeric(rateMod@phylogeny$pi(rateMod@piDM[1,])), piProb))
## -------------------------------------------------------------------------- ##
testthat::context("rateModel object transition matrix calculations")
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-0.75,0.75,0.25,-0.25),ncol=2,nrow = 2,byrow = TRUE)
qBaseNorm=qBase/(2*0.75*0.25)
qBaseNormE1=log(as.matrix(Matrix::expm(qBaseNorm*0.25*1)))
qBaseNormE2=log(as.matrix(Matrix::expm(qBaseNorm*0.5*0.8)))
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-piProb[2],piProb[2],piProb[1],-piProb[1]),ncol=2,nrow = 2,byrow = TRUE)
qBase
prod(piProb)
prod(piProb)
piProb
0.96267311*0.3732689
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
r0
r1
rm(r0)
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
r0
## Compute rates
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
r0
r1
r2
siteInfo=data.frame(A=0.01,B=0.2)
rateFormula=formula(~A+B)
states=matrix(c(0,1,1),nrow=1)
colnames(states)=tree$tip.label
## Compute site probabilities using epiAllele and construct alleleData object
aData=disCharToProb(states,c(0,1))
ad=alleleData(data=aData,tree=tree,siteInfo = siteInfo)
## Construct two edge group edgeTable
et=getEdgeTable(ad)
et[,edgeGroup:=c(0,1,2)]
##### Begin Tests ######
## -------------------------------------------------------------------------- ##
## construct rateModel
testthat::context("rateModel object can be constructed")
testthat::expect_s4_class(rateMod<-rateModel(data = ad,rateFormula = rateFormula,lineageTable = et),class = "rateModel")
## If rate model object was not constructed don't trigger any further tests
if(exists('rateMod')){
testthat::context("rateModel object getter/setter functions")
## Check that parameter vector is the correct length
testthat::test_that("Parameter vector is retieved correctly",
testthat::expect_equal(getParams(obj = rateMod),rep(1,12)))
testthat::test_that("Parameter vector is set correctly",
testthat::expect_equal({
setParams(rateMod,c(0.1,0.2,0.3),6:8)
getParams(rateMod)[7:9]
},c(0.1,0.2,0.3)))
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
## Check that the stationary distribution, pi is computed correctly
Z=c(1,exp(-sum(rateMod@piDM[1,])))
piProb=Z/sum(Z)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(as.numeric(rateMod@phylogeny$pi(rateMod@piDM[1,])), piProb))
## -------------------------------------------------------------------------- ##
testthat::context("rateModel object transition matrix calculations")
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-piProb[2],piProb[2],piProb[1],-piProb[1]),ncol=2,nrow = 2,byrow = TRUE)
qBaseNorm=qBase/(2*prod(piProb))
## Compute rates
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
## Exponentiate rate matrix
qBaseNormE1=log(as.matrix(Matrix::expm(qBaseNorm*0.25*)))
qBaseNormE2=log(as.matrix(Matrix::expm(qBaseNorm*0.5*0.8)))
qBaseNormE3=log(as.matrix(Matrix::expm(qBaseNorm*2*0.5)))
## Compute tables using functions
tt=data.table::data.table(getTree(rateMod)$edge)
data.table::setnames(x = tt,old=colnames(tt),c("parent","child"))
rates=getParams(rateMod)[getRateIndex(rateMod,edges = tt,siteLabel = "All")]
pi=getParams(rateMod)[getPiIndex(rateMod,siteLabel = "All")]
## Compute transition matricies
logTransMat=epiAllele:::branchRateMatrix(rate = rates,branch.length =  getTree(rateMod)$edge.length,pi = pi)
## Compute log-likelihood
pl1=exp(qBaseNormE1) %*% matrix(c(1,0),ncol = 1)
pl2=exp(qBaseNormE2) %*% matrix(c(0,1),ncol=1)
pl3=exp(qBaseNormE3) %*% matrix(c(0,1),ncol=1)
## Check that the stationary distribution of nucleotide frequencies are retrieved correctly
testthat::test_that("The correct log transition matrix is computed - E1",
testthat::expect_equal(logTransMat[[1]],qBaseNormE1))
testthat::test_that("The correct log transition matrix is computed - E2",
testthat::expect_equal(logTransMat[[2]],qBaseNormE2))
testthat::test_that("The correct log transition matrix is computed - E3",
testthat::expect_equal(logTransMat[[3]],qBaseNormE3))
## Check that the manually computed log-likelihood is equal to the output of the function
testthat::test_that("The correct log-likelihood is computed - E3",
testthat::expect_equal(logSumExp(log(pl1)+log(pl2)+log(pl3)+log(pi)),logLikelihood(obj=rateMod)))
}
testthat::context("rateModel object getter/setter functions")
## Check that parameter vector is the correct length
testthat::test_that("Parameter vector is retieved correctly",
testthat::expect_equal(getParams(obj = rateMod),rep(1,12)))
testthat::test_that("Parameter vector is set correctly",
testthat::expect_equal({
setParams(rateMod,c(0.1,0.2,0.3),6:8)
getParams(rateMod)[7:9]
},c(0.1,0.2,0.3)))
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
## Check that the stationary distribution, pi is computed correctly
Z=c(1,exp(-sum(rateMod@piDM[1,])))
piProb=Z/sum(Z)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(as.numeric(rateMod@phylogeny$pi(rateMod@piDM[1,])), piProb))
## -------------------------------------------------------------------------- ##
testthat::context("rateModel object transition matrix calculations")
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-piProb[2],piProb[2],piProb[1],-piProb[1]),ncol=2,nrow = 2,byrow = TRUE)
qBaseNorm=qBase/(2*prod(piProb))
## Compute rates
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
r0
r1
r2
rateMod@rateDM[1,]
et
et
getTree(ad)
getTree(ad)$edges
getTree(ad)$edge
getTree(ad)$edgeL
getTree(ad)$edge.length
## Exponentiate rate matrix
qBaseNormE1=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[1]*r0)))
qBaseNormE2=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[2]*r1)))
qBaseNormE3=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[3]*r2)))
qBaseNormE1
qBaseNormE2
library(phyloGLM)
##### Begin Tests ######
## -------------------------------------------------------------------------- ##
## construct rateModel
testthat::context("rateModel object can be constructed")
testthat::expect_s4_class(rateMod<-rateModel(data = ad,rateFormula = rateFormula,lineageTable = et),class = "rateModel")
testthat::context("rateModel object getter/setter functions")
## Check that parameter vector is the correct length
testthat::test_that("Parameter vector is retieved correctly",
testthat::expect_equal(getParams(obj = rateMod),rep(1,12)))
testthat::test_that("Parameter vector is set correctly",
testthat::expect_equal({
setParams(rateMod,c(0.1,0.2,0.3),6:8)
getParams(rateMod)[7:9]
},c(0.1,0.2,0.3)))
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
## Check that the stationary distribution, pi is computed correctly
Z=c(1,exp(-sum(rateMod@piDM[1,])))
piProb=Z/sum(Z)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(as.numeric(rateMod@phylogeny$pi(rateMod@piDM[1,])), piProb))
## -------------------------------------------------------------------------- ##
testthat::context("rateModel object transition matrix calculations")
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-piProb[2],piProb[2],piProb[1],-piProb[1]),ncol=2,nrow = 2,byrow = TRUE)
qBaseNorm=qBase/(2*prod(piProb))
## Compute rates
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
## Exponentiate rate matrix
qBaseNormE1=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[1]*r0)))
qBaseNormE2=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[2]*r1)))
qBaseNormE3=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[3]*r2)))
rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length)
rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])
log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])),
qBaseNormE1))
qBaseNormE1)
qBaseNormE1
log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])),
qBaseNormE1))
log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))
str(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
str(qBaseNormE1)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.matrix(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))),
qBaseNormE1))
log(as.matrix(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
str(log(as.matrix(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))))
qBaseNormE1
str(as.matrix(qBaseNormE1))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])),
as.matrix(qBaseNormE1)))
str(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
str(as.matrix(qBaseNormE1))
as.vector(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))))
as.numeric(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))))
as.numeric(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
as.numeric(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
(as.numeric(qBaseNormE1))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))),
as.numeric(qBaseNormE1)))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))),
as.numeric(qBaseNormE1)))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r1,getTree(ad)$edge.length[2]))),
as.numeric(qBaseNormE2)))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r2,getTree(ad)$edge.length[3]))),
as.numeric(qBaseNormE3)))
## Compute log-likelihood
pl1=exp(qBaseNormE1) %*% matrix(c(1,0),ncol = 1)
pl2=exp(qBaseNormE2) %*% matrix(c(0,1),ncol=1)
pl3=exp(qBaseNormE3) %*% matrix(c(0,1),ncol=1)
pl1
pl2
pl3
## Compute log-likelihood
pl1=exp(qBaseNormE1) %*% matrix(c(1,0),ncol = 1)
pl2=exp(qBaseNormE2) %*% matrix(c(0,1),ncol=1)
pl3=exp(qBaseNormE3) %*% matrix(c(0,1),ncol=1)
getTree(ad)
plot(getTree(ad))
logSumExp(log(pl1)+log(pl2)+log(pl3)+log(pi))
obj=rateMod
obj@rateDM[sites,]
sites=1
obj@rateDM[sites,]
obj@alleleData$alleleData@data
obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,],obj@rateDM[sites,],obj@piDM[sites,])
obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,],as.matrix(obj@rateDM[sites,]),as.matrix(obj@piDM[sites,]))
obj@phylogeny$siteLL(as.matrix(obj@alleleData$alleleData@data[sites,]),as.matrix(obj@rateDM[sites,]),as.matrix(obj@piDM[sites,])))
obj@phylogeny$siteLL(as.matrix(obj@alleleData$alleleData@data[sites,]),
as.matrix(obj@rateDM[sites,]),
as.matrix(obj@piDM[sites,]))
as.matrix(obj@alleleData$alleleData@data[sites,])
obj@alleleData$alleleData@data[sites,,drop=FALSE]
obj@rateDM[sites,,drop=FALSE]
obj@piDM[sites,,drop=FALSE]
obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE])
methods::setGeneric("siteLL", function(obj) {
standardGeneric("siteLL")
})
methods::setMethod("siteLL", signature(obj = "rateModel"), function(obj,sites=NULL) {
if(is.null(sites)){
sites=1:nrow(obj@rateDM)
} else if (any(sites==0)){
stop("sites is 1-indexed (at least for now)")
}
return(obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE]))
})
#' Compute sitewise log-likelihoods
#'
#' Compute sitewise log-likelihoods
#' @param x rateModel object
#' @param sites integer vectore of sites that log-likelihoods should be computed for (note: 1-indexed)
#' @rdname siteLL
#' @name siteLL
#' @return vector of parameter values
#' @include rateModel-class.R
#' @export
methods::setGeneric("siteLL", function(obj,sites) {
standardGeneric("siteLL")
})
#' @name siteLL
#' @rdname siteLL
#' @aliases siteLL,rateModel,rateModel-method
methods::setMethod("siteLL", signature(obj = "rateModel"), function(obj,sites=NULL) {
if(is.null(sites)){
sites=1:nrow(obj@rateDM)
} else if (any(sites==0)){
stop("sites is 1-indexed (at least for now)")
}
return(obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE]))
})
siteLL(rateMod)
#' Compute sitewise log-likelihoods
#'
#' Compute sitewise log-likelihoods
#' @param x rateModel object
#' @param sites integer vectore of sites that log-likelihoods should be computed for (note: 1-indexed)
#' @rdname siteLL
#' @name siteLL
#' @return vector of parameter values
#' @include rateModel-class.R
#' @export
methods::setGeneric("siteLL", function(obj,sites=NULL) {
standardGeneric("siteLL")
})
#' @name siteLL
#' @rdname siteLL
#' @aliases siteLL,rateModel,rateModel-method
methods::setMethod("siteLL", signature(obj = "rateModel"), function(obj,sites=NULL) {
if(is.null(sites)){
sites=1:nrow(obj@rateDM)
} else if (any(sites==0)){
stop("sites is 1-indexed (at least for now)")
}
return(obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE]))
})
siteLL(rateMod)
logSumExp(log(pl1)+log(pl2)+log(pl3)+log(pi))
logSumExp(log(pl1)+log(pl2)+log(pl3)+log(piProb))
## Check that the manually computed log-likelihood is equal to the output of the function
testthat::test_that("The correct log-likelihood is computed - E3",
testthat::expect_equal(logSumExp(log(pl1)+log(pl2)+log(pl3)+log(piProb)),logLikelihood(obj=rateMod)))
## Check that the manually computed log-likelihood is equal to the output of the function
testthat::test_that("The correct log-likelihood is computed - E3",
testthat::expect_equal(logSumExp(log(pl1)+log(pl2)+log(pl3)+log(piProb)),siteLL(obj=rateMod)))
library(phyloGLM)
## Set seed for consistency
set.seed(123)
## Simulate random data
species=c("A","B","C","D","E")
aData=lapply(as.list(species),function(x) matrix(runif(120),ncol=3))
names(aData)=species
## Create test trees, both one that will fail, and one that will pass
tree=ape::rtree(n = length(species),tip.label = species)
## Create a data frame with labels
siteLabels=data.frame(cre.class=rep(c("Enhancer","Promoter"),each=nrow(aData[[1]])/2),
go.class=rep(c("A","B"),times=nrow(aData[[1]])/2))
ad=alleleData(data=aData,tree=tree,siteInfo = siteLabels)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
obj=rateMod
obj@fixed
library(phyloGLM)
which(c(TRUE,FALSE))
which(!c(TRUE,FALSE))
which(!c(TRUE,FALSE))-1
library(phyloGLM)
## Set seed for consistency
set.seed(123)
## Simulate random data
species=c("A","B","C","D","E")
aData=lapply(as.list(species),function(x) matrix(runif(120),ncol=3))
names(aData)=species
## Create test trees, both one that will fail, and one that will pass
tree=ape::rtree(n = length(species),tip.label = species)
## Create a data frame with labels
siteLabels=data.frame(cre.class=rep(c("Enhancer","Promoter"),each=nrow(aData[[1]])/2),
go.class=rep(c("A","B"),times=nrow(aData[[1]])/2))
ad=alleleData(data=aData,tree=tree,siteInfo = siteLabels)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
scaledLL(rateMod)
phyloGLM:::scaledLL(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
siteLL(obj = rateMod)
obj=rateMod
getParams(obj)
library(phyloGLM)
fit(rateMod)
getSiteInfo(obj)
library(phyloGLM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
fit(rateMod)
library(phyloGLM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
fit(rateMod)
library(phyloGLM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
fit(rateMod)
siteLL(rateMod)
siteLL(rateMod)
which(is.nan(siteLL(rateMod)))
library(phyloGLM)
## Set seed for consistency
set.seed(123)
## Simulate random data
species=c("A","B","C","D","E")
aData=lapply(as.list(species),function(x) matrix(runif(120),ncol=3))
names(aData)=species
## Create test trees, both one that will fail, and one that will pass
tree=ape::rtree(n = length(species),tip.label = species)
## Create a data frame with labels
siteLabels=data.frame(cre.class=rep(c("Enhancer","Promoter"),each=nrow(aData[[1]])/2),
go.class=rep(c("A","B"),times=nrow(aData[[1]])/2))
ad=alleleData(data=aData,tree=tree,siteInfo = siteLabels)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
siteLL(rateMod)
fit(rateMod)
getParams(rateMod)
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$getRateIndex()
head(rateMod@rateDM)
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$rate(0,rateMod@rateDM)
getParams(obj)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$getRateIndex()
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$rate(0,c(1,1,1))
phyloHMM:::scaledLL(rateMod)
phyloGLM:::scaledLL(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
fit(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
getParams(obj)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
getParams(obj)
getParams(rateMod)
fit(rateMod)
getParams(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$rate(0,rateMod@rateDM)
class(rateMod@rateDM)
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$rate(1,rateMod@rateDM)
