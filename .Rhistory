if(exists('rateMod')){
testthat::context("rateModel object getter/setter functions")
## Check that parameter vector is the correct length
testthat::test_that("Parameter vector is retieved correctly",
testthat::expect_equal(getParams(obj = rateMod),rep(1,12)))
testthat::test_that("Parameter vector is set correctly",
testthat::expect_equal({
setParams(rateMod,c(0.1,0.2,0.3),6:8)
getParams(rateMod)[7:9]
},c(0.1,0.2,0.3)))
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
## Check that the stationary distribution, pi is computed correctly
Z=c(1,exp(-sum(rateMod@piDM[1,])))
piProb=Z/sum(Z)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(as.numeric(rateMod@phylogeny$pi(rateMod@piDM[1,])), piProb))
## -------------------------------------------------------------------------- ##
testthat::context("rateModel object transition matrix calculations")
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-piProb[2],piProb[2],piProb[1],-piProb[1]),ncol=2,nrow = 2,byrow = TRUE)
qBaseNorm=qBase/(2*prod(piProb))
## Compute rates
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
## Exponentiate rate matrix
qBaseNormE1=log(as.matrix(Matrix::expm(qBaseNorm*0.25*)))
qBaseNormE2=log(as.matrix(Matrix::expm(qBaseNorm*0.5*0.8)))
qBaseNormE3=log(as.matrix(Matrix::expm(qBaseNorm*2*0.5)))
## Compute tables using functions
tt=data.table::data.table(getTree(rateMod)$edge)
data.table::setnames(x = tt,old=colnames(tt),c("parent","child"))
rates=getParams(rateMod)[getRateIndex(rateMod,edges = tt,siteLabel = "All")]
pi=getParams(rateMod)[getPiIndex(rateMod,siteLabel = "All")]
## Compute transition matricies
logTransMat=epiAllele:::branchRateMatrix(rate = rates,branch.length =  getTree(rateMod)$edge.length,pi = pi)
## Compute log-likelihood
pl1=exp(qBaseNormE1) %*% matrix(c(1,0),ncol = 1)
pl2=exp(qBaseNormE2) %*% matrix(c(0,1),ncol=1)
pl3=exp(qBaseNormE3) %*% matrix(c(0,1),ncol=1)
## Check that the stationary distribution of nucleotide frequencies are retrieved correctly
testthat::test_that("The correct log transition matrix is computed - E1",
testthat::expect_equal(logTransMat[[1]],qBaseNormE1))
testthat::test_that("The correct log transition matrix is computed - E2",
testthat::expect_equal(logTransMat[[2]],qBaseNormE2))
testthat::test_that("The correct log transition matrix is computed - E3",
testthat::expect_equal(logTransMat[[3]],qBaseNormE3))
## Check that the manually computed log-likelihood is equal to the output of the function
testthat::test_that("The correct log-likelihood is computed - E3",
testthat::expect_equal(logSumExp(log(pl1)+log(pl2)+log(pl3)+log(pi)),logLikelihood(obj=rateMod)))
}
testthat::context("rateModel object getter/setter functions")
## Check that parameter vector is the correct length
testthat::test_that("Parameter vector is retieved correctly",
testthat::expect_equal(getParams(obj = rateMod),rep(1,12)))
testthat::test_that("Parameter vector is set correctly",
testthat::expect_equal({
setParams(rateMod,c(0.1,0.2,0.3),6:8)
getParams(rateMod)[7:9]
},c(0.1,0.2,0.3)))
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
## Check that the stationary distribution, pi is computed correctly
Z=c(1,exp(-sum(rateMod@piDM[1,])))
piProb=Z/sum(Z)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(as.numeric(rateMod@phylogeny$pi(rateMod@piDM[1,])), piProb))
## -------------------------------------------------------------------------- ##
testthat::context("rateModel object transition matrix calculations")
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-piProb[2],piProb[2],piProb[1],-piProb[1]),ncol=2,nrow = 2,byrow = TRUE)
qBaseNorm=qBase/(2*prod(piProb))
## Compute rates
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
r0
r1
r2
rateMod@rateDM[1,]
et
et
getTree(ad)
getTree(ad)$edges
getTree(ad)$edge
getTree(ad)$edgeL
getTree(ad)$edge.length
## Exponentiate rate matrix
qBaseNormE1=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[1]*r0)))
qBaseNormE2=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[2]*r1)))
qBaseNormE3=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[3]*r2)))
qBaseNormE1
qBaseNormE2
library(phyloGLM)
##### Begin Tests ######
## -------------------------------------------------------------------------- ##
## construct rateModel
testthat::context("rateModel object can be constructed")
testthat::expect_s4_class(rateMod<-rateModel(data = ad,rateFormula = rateFormula,lineageTable = et),class = "rateModel")
testthat::context("rateModel object getter/setter functions")
## Check that parameter vector is the correct length
testthat::test_that("Parameter vector is retieved correctly",
testthat::expect_equal(getParams(obj = rateMod),rep(1,12)))
testthat::test_that("Parameter vector is set correctly",
testthat::expect_equal({
setParams(rateMod,c(0.1,0.2,0.3),6:8)
getParams(rateMod)[7:9]
},c(0.1,0.2,0.3)))
## Test that correct rate calculations are performed for each group
testthat::test_that("Branch specific rate calculations",
testthat::expect_equal({
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
c(r0,r1,r2)},
c(exp(sum(rateMod@rateDM[1,])),exp(sum(rateMod@rateDM[1,])),
exp(sum(c(0.1,0.2,0.3)*rateMod@rateDM[1,])))))
## Check that the stationary distribution, pi is computed correctly
Z=c(1,exp(-sum(rateMod@piDM[1,])))
piProb=Z/sum(Z)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(as.numeric(rateMod@phylogeny$pi(rateMod@piDM[1,])), piProb))
## -------------------------------------------------------------------------- ##
testthat::context("rateModel object transition matrix calculations")
## Compute transition tables by hand and compare to function computed ones
qBase=matrix(c(-piProb[2],piProb[2],piProb[1],-piProb[1]),ncol=2,nrow = 2,byrow = TRUE)
qBaseNorm=qBase/(2*prod(piProb))
## Compute rates
r0=rateMod@phylogeny$rate(0,rateMod@rateDM[1,])
r1=rateMod@phylogeny$rate(1,rateMod@rateDM[1,])
r2=rateMod@phylogeny$rate(2,rateMod@rateDM[1,])
## Exponentiate rate matrix
qBaseNormE1=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[1]*r0)))
qBaseNormE2=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[2]*r1)))
qBaseNormE3=log(as.matrix(Matrix::expm(qBaseNorm*getTree(ad)$edge.length[3]*r2)))
rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length)
rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])
log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])),
qBaseNormE1))
qBaseNormE1)
qBaseNormE1
log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])),
qBaseNormE1))
log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))
str(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
str(qBaseNormE1)
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.matrix(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))),
qBaseNormE1))
log(as.matrix(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
str(log(as.matrix(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))))
qBaseNormE1
str(as.matrix(qBaseNormE1))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])),
as.matrix(qBaseNormE1)))
str(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
str(as.matrix(qBaseNormE1))
as.vector(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))))
as.numeric(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))))
as.numeric(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
as.numeric(log(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1])))
(as.numeric(qBaseNormE1))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))),
as.numeric(qBaseNormE1)))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r0,getTree(ad)$edge.length[1]))),
as.numeric(qBaseNormE1)))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r1,getTree(ad)$edge.length[2]))),
as.numeric(qBaseNormE2)))
testthat::test_that("Allele stationary distribution calculations",
testthat::expect_equal(log(as.numeric(rateMod@phylogeny$rateMatrix(piProb,r2,getTree(ad)$edge.length[3]))),
as.numeric(qBaseNormE3)))
## Compute log-likelihood
pl1=exp(qBaseNormE1) %*% matrix(c(1,0),ncol = 1)
pl2=exp(qBaseNormE2) %*% matrix(c(0,1),ncol=1)
pl3=exp(qBaseNormE3) %*% matrix(c(0,1),ncol=1)
pl1
pl2
pl3
## Compute log-likelihood
pl1=exp(qBaseNormE1) %*% matrix(c(1,0),ncol = 1)
pl2=exp(qBaseNormE2) %*% matrix(c(0,1),ncol=1)
pl3=exp(qBaseNormE3) %*% matrix(c(0,1),ncol=1)
getTree(ad)
plot(getTree(ad))
logSumExp(log(pl1)+log(pl2)+log(pl3)+log(pi))
obj=rateMod
obj@rateDM[sites,]
sites=1
obj@rateDM[sites,]
obj@alleleData$alleleData@data
obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,],obj@rateDM[sites,],obj@piDM[sites,])
obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,],as.matrix(obj@rateDM[sites,]),as.matrix(obj@piDM[sites,]))
obj@phylogeny$siteLL(as.matrix(obj@alleleData$alleleData@data[sites,]),as.matrix(obj@rateDM[sites,]),as.matrix(obj@piDM[sites,])))
obj@phylogeny$siteLL(as.matrix(obj@alleleData$alleleData@data[sites,]),
as.matrix(obj@rateDM[sites,]),
as.matrix(obj@piDM[sites,]))
as.matrix(obj@alleleData$alleleData@data[sites,])
obj@alleleData$alleleData@data[sites,,drop=FALSE]
obj@rateDM[sites,,drop=FALSE]
obj@piDM[sites,,drop=FALSE]
obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE])
methods::setGeneric("siteLL", function(obj) {
standardGeneric("siteLL")
})
methods::setMethod("siteLL", signature(obj = "rateModel"), function(obj,sites=NULL) {
if(is.null(sites)){
sites=1:nrow(obj@rateDM)
} else if (any(sites==0)){
stop("sites is 1-indexed (at least for now)")
}
return(obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE]))
})
#' Compute sitewise log-likelihoods
#'
#' Compute sitewise log-likelihoods
#' @param x rateModel object
#' @param sites integer vectore of sites that log-likelihoods should be computed for (note: 1-indexed)
#' @rdname siteLL
#' @name siteLL
#' @return vector of parameter values
#' @include rateModel-class.R
#' @export
methods::setGeneric("siteLL", function(obj,sites) {
standardGeneric("siteLL")
})
#' @name siteLL
#' @rdname siteLL
#' @aliases siteLL,rateModel,rateModel-method
methods::setMethod("siteLL", signature(obj = "rateModel"), function(obj,sites=NULL) {
if(is.null(sites)){
sites=1:nrow(obj@rateDM)
} else if (any(sites==0)){
stop("sites is 1-indexed (at least for now)")
}
return(obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE]))
})
siteLL(rateMod)
#' Compute sitewise log-likelihoods
#'
#' Compute sitewise log-likelihoods
#' @param x rateModel object
#' @param sites integer vectore of sites that log-likelihoods should be computed for (note: 1-indexed)
#' @rdname siteLL
#' @name siteLL
#' @return vector of parameter values
#' @include rateModel-class.R
#' @export
methods::setGeneric("siteLL", function(obj,sites=NULL) {
standardGeneric("siteLL")
})
#' @name siteLL
#' @rdname siteLL
#' @aliases siteLL,rateModel,rateModel-method
methods::setMethod("siteLL", signature(obj = "rateModel"), function(obj,sites=NULL) {
if(is.null(sites)){
sites=1:nrow(obj@rateDM)
} else if (any(sites==0)){
stop("sites is 1-indexed (at least for now)")
}
return(obj@phylogeny$siteLL(obj@alleleData$alleleData@data[sites,,drop=FALSE],
obj@rateDM[sites,,drop=FALSE],
obj@piDM[sites,,drop=FALSE]))
})
siteLL(rateMod)
logSumExp(log(pl1)+log(pl2)+log(pl3)+log(pi))
logSumExp(log(pl1)+log(pl2)+log(pl3)+log(piProb))
## Check that the manually computed log-likelihood is equal to the output of the function
testthat::test_that("The correct log-likelihood is computed - E3",
testthat::expect_equal(logSumExp(log(pl1)+log(pl2)+log(pl3)+log(piProb)),logLikelihood(obj=rateMod)))
## Check that the manually computed log-likelihood is equal to the output of the function
testthat::test_that("The correct log-likelihood is computed - E3",
testthat::expect_equal(logSumExp(log(pl1)+log(pl2)+log(pl3)+log(piProb)),siteLL(obj=rateMod)))
library(phyloGLM)
## Set seed for consistency
set.seed(123)
## Simulate random data
species=c("A","B","C","D","E")
aData=lapply(as.list(species),function(x) matrix(runif(120),ncol=3))
names(aData)=species
## Create test trees, both one that will fail, and one that will pass
tree=ape::rtree(n = length(species),tip.label = species)
## Create a data frame with labels
siteLabels=data.frame(cre.class=rep(c("Enhancer","Promoter"),each=nrow(aData[[1]])/2),
go.class=rep(c("A","B"),times=nrow(aData[[1]])/2))
ad=alleleData(data=aData,tree=tree,siteInfo = siteLabels)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
obj=rateMod
obj@fixed
library(phyloGLM)
which(c(TRUE,FALSE))
which(!c(TRUE,FALSE))
which(!c(TRUE,FALSE))-1
library(phyloGLM)
## Set seed for consistency
set.seed(123)
## Simulate random data
species=c("A","B","C","D","E")
aData=lapply(as.list(species),function(x) matrix(runif(120),ncol=3))
names(aData)=species
## Create test trees, both one that will fail, and one that will pass
tree=ape::rtree(n = length(species),tip.label = species)
## Create a data frame with labels
siteLabels=data.frame(cre.class=rep(c("Enhancer","Promoter"),each=nrow(aData[[1]])/2),
go.class=rep(c("A","B"),times=nrow(aData[[1]])/2))
ad=alleleData(data=aData,tree=tree,siteInfo = siteLabels)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
scaledLL(rateMod)
phyloGLM:::scaledLL(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
siteLL(obj = rateMod)
obj=rateMod
getParams(obj)
library(phyloGLM)
fit(rateMod)
getSiteInfo(obj)
library(phyloGLM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
fit(rateMod)
library(phyloGLM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
fit(rateMod)
library(phyloGLM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
fit(rateMod)
siteLL(rateMod)
siteLL(rateMod)
which(is.nan(siteLL(rateMod)))
library(phyloGLM)
## Set seed for consistency
set.seed(123)
## Simulate random data
species=c("A","B","C","D","E")
aData=lapply(as.list(species),function(x) matrix(runif(120),ncol=3))
names(aData)=species
## Create test trees, both one that will fail, and one that will pass
tree=ape::rtree(n = length(species),tip.label = species)
## Create a data frame with labels
siteLabels=data.frame(cre.class=rep(c("Enhancer","Promoter"),each=nrow(aData[[1]])/2),
go.class=rep(c("A","B"),times=nrow(aData[[1]])/2))
ad=alleleData(data=aData,tree=tree,siteInfo = siteLabels)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
siteLL(rateMod)
fit(rateMod)
getParams(rateMod)
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$getRateIndex()
head(rateMod@rateDM)
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$rate(0,rateMod@rateDM)
getParams(obj)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$getRateIndex()
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$rate(0,c(1,1,1))
phyloHMM:::scaledLL(rateMod)
phyloGLM:::scaledLL(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
fit(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
getParams(obj)
rateMod=rateModel(data = ad,rateFormula=formula(~cre.class+go.class))
getParams(obj)
getParams(rateMod)
fit(rateMod)
getParams(rateMod)
phyloGLM:::scaledLL(obj = rateMod)
rateMod@phylogeny$getRateIndex()
rateMod@phylogeny$rate(0,rateMod@rateDM)
class(rateMod@rateDM)
rateMod@phylogeny$rate(0,rateMod@rateDM)
rateMod@phylogeny$rate(1,rateMod@rateDM)
install.packages("Rcpp")
install.packages("nloptr")
install.packages("RcppArmadillo")
library(phyloGLM)
Rcpp::compileAttributes()
library(phyloGLM)
library(phyloGLM)
library(phyloGLM)
library(phyloGLM)
phyloGLM:::expokit_dgpadm(mat(1:9,ncol=3,nrow=3),2)
phyloGLM:::expokit_dgpadm(matrix(1:9,ncol=3,nrow=3),2)
install.packages("kexpmv")
kexpmv::expokit_dgpadm(matrix(1:9,3,3),3)
install.packages("microbenchmark")
microbenchmark::microbenchmark(kexpmv::expokit_dgpadm(matrix(1:9,3,3),3))
library(phyloGLM)
phyloGLM::expokit_dgpadm(matrix(1:9,3,3),3)
phyloGLM:::expokit_dgpadm(matrix(1:9,3,3),3)
phyloGLM:::mydgexpv_
phyloGLM:::mydgmexpv_
phyloGLM:::wrapdgpadm_
phyloGLM:::expokit_dgpadm(matrix(1:9,3,3),3)
phyloGLM:::wrapdgpadm_
phyloGLM:::expokit_dgpadm(matrix(1:9,3,3),3)
Rcpp::compileAttributes()
library(phyloGLM)
Rcpp::compileAttributes()
phyloGLM:::expokit_dgpadm(matrix(1:9,3,3),3)
library(phyloGLM)
phyloGLM:::expokit_dgpadm(matrix(1:9,3,3),3)
phyloGLM:::wrapdgpadm_
double(length = 2*2)
double(length = 2*2)
matrix(1:4,ncol=2,nrow=2)
as.numeric(matrix(1:4,ncol=2,nrow=2))
as.numeric(t(matrix(1:4,ncol=2,nrow=2)))
m=matrix(1:4,ncol=2,nrow=2)
t=2
transpose_needed=TRUE
# Check if mat is blank
if (is.null(mat))
{
# Default mat
cat("\nWARNING: expokit_dgpadm() was provided a mat with value NULL.  Example mat provided instead\n")
mat=matrix(c(-0.071207, 0, 0, 0.065573, -0.041206, 0, 0.005634, 0.014206, 0), nrow=3, byrow=TRUE)
}
# Check if t is blank
if (is.null(t))
mat=matrix(1:4,ncol=2,nrow=2)
# FOR DGPADM
ideg = as.integer(6)
# Order (numrows/numcols) of the matrix
m = as.integer(nrow(mat))
# Check if mat is blank
if (is.null(mat))
{
# Default mat
cat("\nWARNING: expokit_dgpadm() was provided a mat with value NULL.  Example mat provided instead\n")
mat=matrix(c(-0.071207, 0, 0, 0.065573, -0.041206, 0, 0.005634, 0.014206, 0), nrow=3, byrow=TRUE)
}
# Check if t is blank
if (is.null(t))
matr
mat
mat=matrix(1:4,ncol=2,nrow=2)
mat
t
transpose_needed=TRUE
# FOR DGPADM
ideg = as.integer(6)
# Order (numrows/numcols) of the matrix
m = as.integer(nrow(mat))
# output matrix
res = double(length=m*m)
# Transpose matrix, if required
matvec = mat
if (transpose_needed == TRUE)
{
tmatvec = t(matvec)
H = as.numeric(tmatvec)
} else {
H = as.numeric(matvec)
}
# (ldh,m):(input) argument matrix
ldh = m
# lwsp = length of wsp, the workspace
# wsp(lwsp):(workspace/output) lwsp .ge. 4*m*m+ideg+1
lwsp = as.integer(4*m*m+ideg+1)
wsp = double(length=lwsp)
# ipiv(m)   : (workspace)
ipiv = integer(length=m)
# iexph:(output) number such that wsp(iexph) points to exp(tH)
# i.e., exp(tH) is located at wsp(iexph ... iexph+m*m-1)
iexph = as.integer(0)
# ns:(output) number of scaling-squaring used
ns = as.integer(0)
# iflag:(output) exit flag
# 0 - no problem
# <0 - problem
iflag = as.integer(0)
# Run the function:
res <- .C("wrapdgpadm_", as.integer(ideg), as.integer(m), as.double(t), as.double(H), as.integer(ldh), as.double(wsp), as.integer(lwsp), as.integer(ipiv), as.integer(iexph), as.integer(ns), as.integer(iflag))
c(1,2,3)[[2]]
library(phyloGLM)
library(phyloGLM)
phyloGLM:::expokit_dgpadm(matrix(1:4,nrow=2,ncol=2),t=2)
